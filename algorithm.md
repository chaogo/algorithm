## 程序调试标准动作：
- 查看变量的值，展开实例看内部成员变量的值
- step over:执行一行
- step into: 进入被调用方法内部继续调试
- step out: 继续执行到方法结束，返回调用方法的地方
- Resume program: 继续执行程序（不管是否有方法调用）直到遇到下一个断点或程序结束
- Evaluate Expression: 在对话框输入代码(表达式），直接执行看结果值
- 条件断点： 给断点设置条件，只有满足条件时，程序才会在该断点挺住

## 遇到不会的题
- 看思路，自己实现代码
- 如果还是遇到问题，返回来对照代码，千万不要一头扎进别人的代码

八股文
- 操作系统、计算机网络、Java、常用框架、中间件、架构设计、解决方案。。。
- 多看看，背背
- 主要看广度，什么都看一看，不用太深挖，但得知道一些，就行


## 刷题姿势
- 刷题目标：
  - 数量：easy 每题 1 分，medium 每题 3 分，hard 每题 5 分 -> 刚开始刷题的时候，每日目标 20 分；之后加量至每日目标 30 分。
  - 计时：保证 easy 题目5min 内写完，medium 题 10-15min，hard 题 15-20min -> 让自己注意力集中，提高练习效率
  - 一次AC：白板刷题 -> 后期要能脱离IDE，尽力一次写出bug free的代码
  - 测试：如果不能一次AC, 在没有未通过测试用例提示的情况下，如何设计test cases找出bug
  - 讲：把每道题给自己讲明白，也给别人讲明白 -> 讨论：针对某题，核心算法是，递推公式是，最终时间复杂度是XXX，空间复杂度是XXX... 确认自己是真的懂了
  - 总体能力：medium题秒&&想啥写啥 -> easy, medium题能马上想到最优解，想到一个解法能马上写出来且bug free
- 面试目标：是一个展示自己作为合作者的过程。除了算法本身，如何沟通，把题目弄清楚，完成面试官对你的各方面预期是极其重要的。那么面试过程中，如何表现呢？
  1. 听题+记录
     听/看题的时候要把题目抽象转化为若干项RI(requirement Item)并记录，另时间、空间复杂度也是两个特殊的RI
  2. 复述+追问
  3. 设计输入输出
     对于给定的输入，在极端情况下，程序该怎么办？
     - 对于int: Integer.Max
     - 对于String: null, ""
     - 对于数组：...
  4. 思路解释，向面试官求证
     - 哪怕不是最优解法，起码把自己的所有想法展示出来，不要让面试官认为你啥都不会
  5. 复杂度分析
     - 有些不是准确的O(n),或O(logN), 可以"近似", 近似的O(log)时间复杂度
  6. 设计边界条件
  7. 编码
     - 规范coding style: 变量名...
     - 尽量避免高级语法
  8. 运行测试用例
     主动跑一些case检查程序的正确性，设计case也是考察的点
  9. 期待 follow up
     - 算法分析: 当前代码还有哪些不好？结合使用的语言还可以有哪些优化？如果把输入改成更一般的情况，程序该如果调整？
     - 思路讲解

- 按题目类型集中刷题 ——> 随机限时刷题 ——> 模拟面试

- 提升写代码速度
  - 快捷键： 切换窗口、移动光标、代码提示……
  - 模版：代码框架、预定义常用function, class……
  - 熟练：预判接下来的进程


## 纯编程题
1. 纯编程题也是算法面试（算法能力+编程能力）的重要环节
2. 不涉及任何数据结构和算法，一看就知道怎么做，但实现起来比较繁琐，边界处理复杂，需要考虑特殊情况比较多
3. 解题技巧
   - 先忽略掉不容易处理的特殊情况，只考虑正常情况，简化编程
   - 写代码前先写注释，通过注释让代码模块化，让思路更清晰
   - 写完代码多举几个特例，来验证代码是否正确 （特别是面试时,验证后，再提交面试官）
4. 例题 IP地址解析
   1. 举例读懂题意，梳理题目要求
   2. **列出测试用例（测试驱动开发）** ——测试用例一定要覆盖全各种情况，后面验证时也会用到
   3. 总结归纳处理思路（**把逻辑中重复部分抽象出来**）
   4. 第一轮编写代码（写注释，让代码模块化，逻辑更清晰）
   5. 使用测试用例验证代码，并完善代码
5. 调函数
   1. 如果这个函数就是这个题目的核心逻辑，该函数不能用
   2. 如果是题目的非核心逻辑，只是整个处理逻辑的一小部分，则可以用


## 找规律题
1. 不太常考，不要花太多时间
2. 有点类似智力题，但比智力题简单，难在找规律，编程实现简单
3. 解题技巧： 举例总结规律，猜想举例验证
4. 例题： 现有x瓶啤酒，每3个空瓶子换一瓶啤酒，每7个瓶盖子也可以换一瓶啤酒，问最后可以喝多少瓶酒。


从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。
数据结构是为算法服务的，算法要作用在特定的数据结构之上。
数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上构建算法，孤立存在的数据结构就是没用的。


## 数组和链表
1. 支持动态扩容的数组： Java ArrayList
2. **数据结构 ！= 数据类型 ——> 数据结构数组跟编程语言中的数组有区别**
   - JavaScript数组： `var arr = new Array(4, 'hello', new Date())`
   - 数组用一片连续的内存空间，来存储一组具有相同数据类型的数据 ——> 数据结构中的数组是抛开编程语言来说的
   - 编程语言中提供的数组是一种数据类型，每种编程语言会结合自己语言的实现特点，对数组这种数据类型得到实现做调整，并不会完全按照数据结构中数组的定
3. 链表使用非连续的内存空间来存储数据，通过next指针将内存块串联在一起
4. 头指针(head) ——> 头结点(可无) ——> 首元结点 ——> ... ——> 尾结点 ——> null
   - 当内存里存的是另一个内存块的地址时，就表示指向，所以头指针head, next指针, null都表示指向下一结点，相对直接说就是下一结点更加准确
   - 头指针是链表所必须的，无论链表是否为空，头指针均不为空。头指针就是一个指针，没有数据，标识链表的名字
     - 例程**`Node p = new Node();`，Java申请了一个空的"Node形状"的内存空间，同时申请了一个内存存储引用（指针）p，来指向它**
     - **指针不但标识了地址，还有指向的数据类型（形状、大小）**
     - 等号（赋值）号前表示引用，赋值号后表示开辟了该引用类型对应的内存空间；在例如`Node p = null`表示p指向为空，而不是p为空 
     - "="描述为"指向"；"="左边表示被赋值的变量；"="右边的表示取值；"."表示指针/引用所指对象的某个成员变量
       - 1.`p = p.next;` 2.`p.next = p.next.next;` 这里都是引用之间的相互赋值，没有开辟新空间
       - **对1，如p保存的地址为1024，p.next保存的地址为1084，将p赋值为1084就意味着p指向了p.next指向的结点**
       - 原因：只有指针/引用/地址可以被赋值，结点本身只能用引用表示，不可以直接被赋值；对其它引用类型也一样
     - C/C++中对指针用*标识，而Java中没有表示标识——引用？
   - 头结点不是链表所必须的。是为了操作的统一与方便而设立的（比如在第一个结点前添加结点，使得所有结点的处理逻辑一致），放在第一个元素结点之前，其数据域一般无意义（有些情况也可存放链表长度、用作监视哨等）
5. 链表的遍历、查找、插入、删除
   - 遍历 ——> 查找
   - 插入：
     - 在链表头部插入元素: 直接插入O(1)
       ```Java
       public void insertAtHead(int value) {
            Node newNode = new Node(value, null);
            newNode.next = head;
            head = newNode;
       }
       ```
     - 在链表尾部插入元素：遍历找到尾结点插入，O(n)复杂度太高
       ```Java
       public void insertAtTail(int value) {
           Node newNode = new Node(value, null);
           if (head == null) { // 优化2
               head = newNode;
           } else {
               Node p = head;
               while (p.next != null) { // 优化1
                   p = p.next;
               }
               p.next = newNode;   
           }
       }
       ```
       - 优化1：记录尾结点位置，使得不用每次都去遍历,将为O(1),`private Node tail = null;`,特殊情况：当只有一个结点时head与tail指向重合
       - 优化2：**引入头结点（也叫虚拟结点/哑结点/哨兵结点）**，简化编程，统一处理逻辑，是链表中非常常用的编程技巧
       - 优化后的代码。但现在的链表的第一个结点变为head.next。
         ```Java
         private Node head = new Node();
         private Node tail = head;
              
         public void insertAtTail(int value) {
           Node newNode = new Node(value, null);
           tail.next = newNode;
           tail = newNode;
         }
         ```
     - 在给定结点之后插入元素
       ```Java
       public void insertAfter(Node p, int value) {
         if (p == null) {
             return;
         }
         Node newNode = new Node(value, null);
         newNode.next = p.next;
         p.next = newNode;
       }
       ```
   - 删除：
     - 删除给定结点之后的结点
       ```Java
       public void deleteNextNode(Node p) {
         if (p == null || p.next == null) {
             return;
         }
         p.next = p.next.next; // 级联的".": 前面表示取内存块，最后的"."才表示取值（这里最后next是地址值）
       }
       ```
     - 删除给定结点，头结点优化
       ```Java
       public Node deleteThisNode(Node head, Node p) {
            if (p==null || head == null) {
                return null;
            }    
            Node newHead = new Node();
            newHead.next = head;
            Node prev = newHead;
            Node q = head;
            while (q != null) return head;
            prev.next = prev.next.next;  // 这里不同再判断是否是删除头结点了
            return newHead.next;
       }
       ```
6. 其它链表结构：循环链表、双向链表（支持O(1)时间复杂度内快速找到给定结点的前驱结点，在工程中很常用）、双向循环链表
7. Java语言中的链表实现：LinkedList,对双向链表做了封装，提供了更好的接口
8. 链表题型特点
   - 面试很常考，是重中之重
   - 题型有限，代码实现难： 重点考察的不是算法能力，而是编程能力，面试中基本都是经典题或经典题上稍加改造
   - 因此需要掌握链表题的编程技巧；把经典题写熟练
9. 解体技巧
   1. 都会涉及"遍历"，核心是通过"画图举例"确定遍历的"三要素"
      1. 遍历的结束条件：`p==null or p.next==null`
      2. 指针的初始值： `p=head or ...`
      3. 遍历的核心逻辑：...（视题目要求而定）
   2. 特殊情况处理： 头结点、首元结点、尾结点、空链表
   3. 引入虚拟头结点？
   4. 另，一个重要的逻辑更加清晰的技巧——改变链表的万能写法：新开一个结果链表，空链表（头结点），将符合要求的结点依次挂到新链表上，**注意这样其实只是改变了结点间的连接关系，并没有提高空间复杂度**  ——> 例题："删除链表中的元素"
   5. 操作过程中的尾结点也置为null,使逻辑更加清晰，避免奇怪的错误（如环）

## 栈和队列
### 基础知识
1.栈
- 操作受限的线性表，只允许在一端插入和删除数据，
- 两个核心功能：push, pop，另外一个重要的是peek
- 两种实现方式：基于数组（顺序栈）和基于链表（链式栈）
- 顺序栈：在数组的尾部插入和删除，用count指向当前栈顶元素
- 链式栈：**将链表头部head作为栈顶** (若将尾部作为栈顶，由于单链表，删除tail后无法返回下一结点)
- Java中的栈 java.util.Stack, **这是一个类**`Stack<Integer> stack = new Stack<>()`
2. 队列
- 操作受限的线性表，队列头取数据，尾部插入数据
- 两种实现方式：基于数组（固定大小，有限队列）和基于队列（可变大小，无限队列）
- 基于数组（循环队列）：head,tail总是指向队首和队尾， **留了一个空间没有使用，以便区分队满和队空**，（当然也可以用count来记录数据）
  ```Java
  public class CircularQueue {
    private String[] items;
    private int n;
    private int head = 0;
    private int tail = 0;
  
    public CircularQueur(int n) {
        this.items = new String[n];
        this.n = n;
    }
  
    pubic boolean enqueue(String item) {
        if ((tail+1) % n == head) return false; // "浪费"了一个空间
        items[tail] = item;
        tail = (tail+1) % n;
        return true; 
    }
  
    public String dequeue() {}
        if (tail == head) retrun null;
        String ret = items[head];
        head = (head+1) % n;
        return ret;
    }
  ```
- 基于链表：head作为队首，删除数据（原理与链式栈一致，删了结点后得能容易达到下一结点）； tail作为队尾，插入数据
- Java中的队列： java.util.Queue; 
  - **与Stack不同，这是一个接口：** `public interface Queue<E> extends Collection<E>;`
  - 需要new一个它的实现，`Queue<Integer> queue = new LinkedList<Integer>();`
  - 入队：
    - offer(添加一个元素并返回true,如果队列已满则返回false）--重要
    - add（添加一个元素并返回true,如果队列已满则抛出相应异常）
    - put (添加一个元素并返回true,如果队列已满则阻塞)
  - 出队：
    - poll（移除并返回队列头部的元素，若队列为空则返回null） --重要
    - remove（移除并返回队列头部的元素，若队列为空则抛出相应异常）
    - take (移除并返回队列头部的元素，若队列为空则阻塞)
  - 取队首元素：
    - peek （返回队列头部的元素，若队列为空则返回null) --重要
    - element(返回队列头部的元素，若队列为空则抛出相应异常)

### 题型套路
1. 栈的出题量远多于队列；（优先级队列会在堆中涉及）
2. 细分题型
   - 直接以栈为背景： 用栈实现队列、最小栈、栈排序
     - 两种思路：1.直接入，出的时候倒腾；2.入的时候倒腾，直接出；（3.入和出的时候都倒腾，也可，但逻辑不必要地变复杂了）
     - 对于用两个栈实现队列：方式1最优；对于用队列实现栈：一个队列，方式2最优；
     - 最小栈仍是栈，栈排序的栈已经不是栈了；**排序栈不是后进先出，而是最小值先出，类似优先级队列，不是先进先出，而是优先级最高的先出**
   - 连连消：字符串连连消、求表达式
   - 单调栈：如接雨水、求正方形面积
     - 栈延伸出来的一种新的数据结构；不多不怎么考比较难；
     - 一般来说，能用单调栈解决的题目，暴力 或 前缀后缀统计 都能解决，只是时间复杂度稍高；
     - **前缀后缀统计，将重复的动作分开来，以空间换时间，这种思路很重要**


## 递归和分治
### 基础知识
1. 递归和分治的关系 
   - 分治是一种思想：分而治之；将原问题划分成多个规模更小并且结构与原问题相同的子问题，先解决这些子问题，然后再合并其结果，就得到原问题的解。
   - 递归是一种编程技巧：一个函数自己调用自己
   - 递归也具有结构相同，规模不同的特点，所以，涉及用分治思想解决的问题，比较适合用递归来实现
2. 函数调用栈
   - 栈帧：为函数执行在栈上开辟了一个空间，把函数里的参数、局部变量、返回地址（返回到上一层函数继续执行的位置）等现场信息封装成栈帧，压倒函数调用栈中
   - 递归调用的过程跟普通函数调用过程是一致的
   - 递归函数调用的特点： **先递：函数压栈； 再归：函数出栈；**
   - 更复杂情况如（`return f(n-1)+f(n-2)`)的分析： **递归树: 箭头向下是递的过程，箭头向上是归的过程** 
     - --> 不再是一次都"递"出去，一次都"归"回来了，而是"递"和"归"夹杂
     - 递归树的高度等于递归调用栈的最大深度，**也等于空间复杂度**
3. 堆栈溢出
   - 大部分是工程上的问题；刷题时溢出一般是有bug了
   - 如何解决：限制递归深度；改用非递归实现
4. 重复计算
    - 备忘录：**当有些全局变量需要定义的时候，我们可以在递归函数外面嵌套一个非递归的壳**
      如 爬楼梯
   ```Java
      private int[] mem;
      public int f(int n) {
        mem = new int[n+1];
        return f_r(n);
      }
      
      private int f_r(int n) {
        if (n==1) return 1;
        if (n==2) return 2;
        if (mem[n] != 0) return mem[n];
        mem[n] = f_r(n-1) + f_r(n-2);
        return mem[n];
      }
      ```
    - 考虑是否可以用DP解决（回溯这类代码）
5. 编写递归代码的技巧
   - 怎么发现这个问题可以用递归来做
     1. 存在最小子问题，可以直接返回结果（递归终止条件）
     2. 规模更小的问题，跟规模更大的问题，解决思路相同  --> 这一条只是去确定，没有具体内容
     3. 利用子问题的解可以**组合**得到原问题的解
   - 递归的正确编写姿势
     - 假设子问题已经解决（a,b)，在此基础上思考如何解决原问题(c)
     - 基于此，**确定递推公式（c)+终止条件(a)**，然后翻译成代码
   - **注意千万不要试图想清楚详细的递和归的执行过程，会干扰主要的思路**， 典型例子:反转链表的递归解法
6. 递归的时间和空间复杂度分析
   - 时间复杂度
     - 递推公式：某些情况
     - 递归树：比较普适
   - 空间复杂度
     - **跟递归函数调用栈最大深度成正比** 也即递归树的深度
     - 空间复杂度跟时间复杂度不同，空间会释放了以后再用，因此空间复杂度不是累加值，而是峰值。
7. 两条线： 
   - 递归 ——> 记忆化搜索（带备忘录的递归、剪枝） ——> 动态规划 ——> 进一步空间优化
   - 回溯 ——> 动规 ——> 贪心 

### 题型套路
1. 面试很少单纯考递归，但是基础中但基础；二叉树、回溯、DFS是面试的重中之重，他们都需要用到递归
2. 解题技巧：寻找重复结构 -> **写递推公式，包括终止条件**
3. 递归代码的一般格式
   ```Java
   void 递归函数(参数) {
        终止条件if...return
        ..前置逻辑..
        递归函数(参数); // 子问题
        是否有现场需要手动恢复(全局变量)
        ..后置逻辑..
   }
   ```
   

## 排序
### 基础知识
1. 评价指标: 
    - 时间复杂度
    - 空间复杂度
    - 原地性
    - 稳定性：
      - 在实际软件开发中，我们要排序的往往不是单纯的整数和字符，而是复杂的数据类型"对象"，我们按照对象的某个属性来排序
      - 给一组学生排序，按照身高从低到高排序，身高相同的按照体重从小到达排序： 先排体重，再稳定地排身高
2. 冒泡排序
   - 算法：n次冒泡（遍历），当相邻两个数据不满足顺序要求时，交换
   - 优化：如果某一次冒泡过程中，没有发生一次交换，说明已经有序了，可以提前停止
   - 评价：时间复杂度（最好O(n),最坏O(n2)）, 空间复杂度O(1), 原地, 稳定（保证在相邻元素相等时不交换）
   - 平均时间复杂度分析：
     - 有序度、逆序度： 排序就是一个有序度提高，逆序度降低的过程。 逆序度 = 满有序度（(n*(n-1))/2) - 有序度
     - 核心操作是比较和交换，比较次数大于交换次数，交换次数等于逆序度，逆序度的平均值（中间值）为n*(n-1)/4, 因而O(n2)
3. 插入排序和选择排序
   - **都将数据分为已排序区间和未排序区间，插入排序是确定元素找位置，选择排序是确定位置找元素**
   - 插入排序
     - 算法：将数组中的数据分为已排序区间和未排序区间，（初始已排序区间只有一个元素） 取未排序区间中的元素，在已排序区间中找合适的插入位置将其插入，重复这个过程，直到未排序区间中的元素为空
     - 插入时，从后往前找位置和从前往后找位置的复杂度是差不多的，但**从后往前有一个好处时，当序列越有序，会越快, O(n)**, 若从前往后的话，对完全有序的情况，每一次插入都要扫描前面的所有元素，O(n2)
     - 评价：时间复杂度(最好O(n)最坏平均O(n2)),空间复杂度(O(1)), 原地, 稳定（保证在等于时不交换）
   - 选择排序
     - 算法：类似插入排序，但选择排序每次从未排序区间中，找到最小的元素，将其与已排序区间后的第一个元素交换；初始时已排序区间为空
     - 评价：时间复杂度(最好最坏平均都是O(n2)),空间复杂度(O(1)), 原地, **不稳定**
4. 归并排序和快速排序
    - 联系
      - 都是将数列一分为二，将两个小的数列分别排序后，再合并；递归编程
      - 归并排序：递的过程简单，直接确定分区位置，不耗时间；归的过程复杂, （双指针，申请新的空间），耗时O(n); 
      - 快速排序：递的过程复杂，只确定分区点的值（并要求左边大右边小），双指针，耗时O(n); 归的过程简单，什么都不用做；
    - 归并排序
      - 算法： 将待排序数组从中间分成前后两部分，对它们分别排序，再将排好序的两部分合并
      - 实现： 递归、双指针、临时数组
      - 评价： 时间复杂度(o(nlogn))，空间复杂度(O(n))，非原地，稳定（保证在合并时相等的情况下左边的先放入临时数组）
      - 时间复杂度和空间复杂度的分析
        - 对于时间： 递归树每层耗时O(n),树高为n
        - 对于空间： 在弹出栈时才申请临时数组，用完被释放，不累加，最大的临时数组大小为n
    - 快速排序
      - 算法：获得分区点，使得分区点pivot左边的元素比pivot上的元素小，右边的大；接着对左右区间分别快排。
      - 实现：
        - 找分区点：最简单的确定分区点的方法是直接取当前区间最后一个元素
        - 交换： 用双指针，i指向左边分区的末尾，j用以遍历，当`a[j]<a[r]`时，将`a[j]`放到i的位置，即与`a[i]`交换
      - 评价：时间复杂度(最好、平均O(nlogn),分区极不均匀原数列完全有序最坏O(n2))，空间复杂度(即递归栈深度，O(logn))，原地，非稳定

### 题型套路
1. 特殊排序 e.g. 奇偶排序
2. TOP K, 快排
3. 链表上的排序
4. 排序预处理


## 哈希表
### 基础知识
1. 由来
   - 一一映射; 快速查找
2. 冲突解决办法
   - 链表法
   - 开放寻址法： 线性探测、二次探测、双重哈希
3. 动态扩容
   - 预先不知道有多少数据会插入到哈希表的情况下，只能预先给哈希表设置一个起始大小
   - 当哈希表中的数据越来越大，哈希表的性能随着装入数据的个数而降低，到一定程度，就出发扩容
   - 装载因子 = 数据个数 / 槽（slot)的个数
   - 实现： 类似数组的扩容，申请一个更大的哈希表，将原哈希表中的数据 （这个过程比较耗时）
   - **为了解决集中扩容耗时过多的问题，我们将扩容操作穿插在多次插入操作的过程中，分批完成**
     - 也会带来问题： 老的内存空间不能释放；查询时可能需要在两边都查找；
     - **设计就是权衡** （根据实际需求）
4. Java HashMap/HashSet
   - HashSet 只存key, 不存value; 即查找时前后都是key; 存bool值的话（位图），Set里都是true/false了，信息变少了（哈希不能反推key);
5. 哈希表的扩展：位图、布隆过滤器
   - 位图
     - 下标与数据一一映射
     - 元素类型为布尔值，——> "位"
     - e.g. 有1000万个整数，范围0～3000万，如何快速判定某个数据是否出现在这1000万个数据中？开辟大小为3000万的布尔数组，下标表示数据，值表示存在与否
     - 某些语言boolean不止占一个二进制位，因此可能需要自己模拟，用位运算
   - 布隆过滤器
     - 存在冲突误判的位图
     - e.g. 有1000万个整数，范围0～10亿，如何判定某个数据是否出现在这1000万个数据中？
     - 位图，大小4000万，哈希冲突导致误判
       - 判定存在，有可能不存在（误判）
       - 判定不存在 ——> 肯定不存在 (不会误判)
     - 因此虽然有误判，但也有使用场景（肯定不存在的占大多数的情况）：如在访问数据库查询数据前，先访问内存中的位图（布隆过滤器），如果经过判定数据不存在，就不需要继续访问数据库，这样就减少了数据库操作
     - 布隆过滤器降低冲突概率的方法： 用多个二进制位（多个哈希函数），都相等才相信，但也会引入新的误判情况
6. 哈希表的存储的过程：即**value并不直接有key计算得出，不参与哈希表构建，而是附在key上，**因此key和value都可以是list等对象
   1. 首先有元组<key, value>, 
   2. **接着（通过哈希函数将key）得到其哈希值hashCode(key), 这就是（对应）一个位置（槽）**
   3. 在这里（通过链表）存储<key,value>

### 题型套路
- 题型说明
  - 大部分情况下，哈希表只是配合解决其它算法类型的题目；
  - 用到哈希表的场景也比较明确，就是为了提高查找效率，让查找时间复杂度降为O(1)
  - 布隆过滤器、位图往往在面试中，大数据处理中，讲讲思路就够了
- 用途： 判重、查找、统计
- 例题
  - 两数之和，三数之和
    - 先扫一遍数组建立起完整哈希表，再扫一遍处理，更加规范
  - LRU缓存
    - 哈希表：快速得到要查找、删除的结点 （地址）
    - 双向有序链表：维护数据的有序性（按照访问时间）


## 二分查找
### 基础知识
1. 原理
    - 要求：**有序** **数组**
    - 时间复杂度O(log2N)
    - 链表不能根据下标快速访问元素，因此在链表中不能实现二分查找，或者说在链表中实现二分查找是不值当的，时间复杂度O(n)
2. 递归和非递归实现
   - 非递归实现: 时间复杂度O(log2N), 空间复杂度O(1)
     - 搜索区间是闭区间；
     - 循环结束条件： low <= high
       - 即`while (low <= high)`
     - 更新low(mid+1), high(mid-1); 返回mid
   - 递归实现: 时间复杂度O(log2N), 空间复杂度即递归栈的深度O(log2N)
     - `public int bsearch_r(int[] a, int low, int high, int value)`

### 题型套路
1. 题型说明
   - 算是重点，但题型/套路比较单一 ： 考察变形二分查找，或二分答案
   - 代码很短，但不容易写对 ：难点：确定搜索区间、循环条件、区间更新、返回值
2. 解题技巧：把条件都附在target上，即在最后的判断上，而不改变整体的代码模版
   - 查找区间永远是闭区间`[low, high]`
   - 循环条件永远是`low <= high`
     - 对于`low == high`的情况，必要的时候特殊处理，在while内部补充退出条件
   - 返回值永远是mid, 而不是low, high
   - low, high的更新永远 **以mid为界**，以此找条件确定`low = mid + 1`和`high = mid - 1`, (特殊：找峰值时high=mid)
   - 对于非确定性查找，使用前后探测法，来确定搜索区间
     - 非确定性查找是指找：第一个、最后一个相等的；第一个大于等于的、最后一个小于等于的；循环数组寻找最小值；寻找峰值
   - 先处理命中（包括真命中和伪命中）的情况，再处理不命中的情况


## 二叉树
### 基础知识
1. 二叉树(BT)
   - 概念： 二叉树、满二叉树、完全二叉树...
   - 存储：
   - 基于指针的存储（大部分情况）
      ```java
     public class Node {
     private int data;
     private Node left;
     private Node right;
     public Node(int data) {this.data = data;}
     }
     ```
     - 基于数组的存储（完全二叉树、堆、线段树（接近完全二叉树））：一般根结点存储在下标为1的位置
   - 遍历（基础中的基础，是其它各种操作的基础）：
     - 前序遍历：根、左、右；中序遍历：左、根、右；后序遍历：左、右、根
     - **前中后序遍历的函数调用栈是一致的** ，因为只是改变了print语句的位置，这不影响函数调用的结构
     - 前中后序遍历都可以看作树上的深度优先遍历（树是一种特殊的图），也属于回溯算法； 
     - **因此三种遍历根本上是一样的，只是在遍历的过程中打印的时机不一样**
2. 二叉查找树(BST)
   - 一种特殊的二叉树，左边小、右边大，（如果有重复，相等的固定放左边或右边）； 支持快速地查找、插入、删除操作 O(logN)
   - 查找： 
     - 递归：如果比root值小，递归地在左子树找； 如果比root值大，递归地在右子树找; O(h), O(h)
     - 非递归：p从root开始查找，如果小，p = p.left; 如果大，p = p.right; O(h), O(1)
   - 插入：**总会插到叶子结点**（总会比当前结点大或者小，一直往下走到头，成为叶子结点）
     - 递归：如果比当前结点小，且左子树为空，直接插，否则递归遍历其左子树；如果大，且右子树为空，直接插，否则递归遍历右子树； 特殊情况：树本身为空； O(h), O(h)
     - 非递归：p从root开始查找，如果小，且左子树为空，直接插，否则p = p.left; 如果大，且右子树为空，直接插，否则p = p.right; O(h), O(1)
   - 删除： 针对待删除结点的子结点个数不同，分三种情况：
     - 待删除结点有0个子结点：将父节点中指向待删除结点的指针置为null
     - 待删除结点有1个子结点：将父节点中指向待删除结点的指针该子结点
     - 待删除结点有2个子结点：**找、替、删** 找到这个结点的右子树中的最小结点（右子树一直往左找），把它替换到要删除的结点，然后用上面两条规则删除"最小结点"（它肯定没有左子结点）； //另，左子树的最大结点也可以
3. 平衡二叉查找树(BBST)
   - BST在频繁的动态更新过程中，可能会出现树的高度远大于log2N的情况，从而导致各个操作的效率下降。极端情况下，二叉树退化为链表，O(n)
   - 平衡二叉查找树：任意一个结点的左右子树高度相差不能大于1，比如AVL树
   - 近似平衡二叉查找树：树的高度近似log2N，比如红黑树
   - 各个操作的性能：完全二叉树>平衡二叉树>近似平衡二叉树
   - 维护平衡的成本：完全二叉树>平衡二叉树>近似平衡二叉树
   - 工程中折中选择近似平衡二叉树（红黑树）
4. Java中的TreeMap, TreeSet
   - 红黑树 —> TreeMap, TreeSet
   - 对应 哈希表 -> HashMap, HashSet
   - 命名：数据结构+功能
   - **都是存储数据的集合（collection），支持快速的查找、插入、删除**

### 题型套路
1. 题型说明：
   - 重中之重，面试常考
   - 二叉树上的操作一般涉及到树的遍历，而且绝大部分题目都使用递归实现
     - 链表：一个叉的的遍历； 二叉树：两个叉的遍历
2. 8类小题型（遍历是核心）
   1. 二叉树上的前中后序遍历(DFS)
      - 递归和非递归实现
   2. 二叉树按层遍历(BFS)
      - 树上的广度优先搜索，队列
      - 用dfs实现层序遍历 （记录行号）
   3. 按照遍历结果反向构建二叉树
      - 递归子问题：左子树前中序遍历结果得到左子树，右子树前中序遍历结果得到右子树；
      - **抓住前序遍历的第一个结点/后序遍历的最后一个结点是根结点**
      - 用数组的下标做递归的参数 (归并排序也是用下标）, （涉及后序遍历时，更新下标时由于去除了根结点，右区间要减1）
   4. 二叉树上的递归 - 很杂
      - 二叉树的最大深度、最小深度
      - 验证平衡二叉树 (求高度的同时顺便验证)
      - 验证对称二叉树（isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left)）
      - 验证二叉搜索树 (递归更新每个子树的取值范围)
   5. 二叉搜索树
      - 借助BST中序遍历结果为有序序列的特点来解题： 左-根-右：从小到大排列； 右-根-左：从大到小排列
      - 两个充要条件
        - 二叉树中序遍历有序 <--> 二叉树是二叉搜索树
        - 对于二叉搜索树root, p是root的左子树上的结点 <--> p.val < root.val
      - 后继者 // 找p的后继结点
        // 若p有右子树，后继结点就是右子树的最左边
        // 若p没有右子树，则其所在树作为左子树的父节点就是其后继结点
        // 若p没有右子树，且其所在树一直是右子树，则p为最右边（最后）一个结点，没有后继结点
   6. LCA最近公共祖先
      - solution1：回溯，通过入栈出栈记录到达p的路径
      - solution2: p, q分别在LCA的左右子树上，或有一个是LCA本身 -> 查找一个树包含多少个p/q (不区分)
   7. 二叉树转单、双、循环链表
      - 将前中后序遍历结果转成链表；类似链表的尾插
   8. 二叉树上的路径 (需要dfs, 往往是preorder或postorder, 但关键在于遍历过程中处理的时机，所以实质记住dfs就好）
      - 二叉树的直径 ((preorder),dfs的同时，返回最长路径长，顺便更新直径)
      - 二叉树和为某一值的路径 （(postorder),dfs的同时，记录当前路径，顺便检查路径和)
      - 有负数的二叉树的最大路径和 （(preorder),dfs的同时，返回root为根的单边的最大路径和，计算root为根的双边的最大路径和并更新）
      - 路径总和III ((pre&postorder), dfs的同时，记录当前路径和，为方便查找差值用哈希表维护，由于和可能重复哈希表的value表示次数)

## 回溯
1. 核心思想
   - **穷举**所有的解，找出其中满足期望的可行解。
   - 为了有规律的枚举所有的可能的解，避免重复和遗漏，把问题求解的过程归纳为**多阶段决策模型** 
   - 整个决策的过程其实就是一棵决策树，遍历决策树过程中记录的**路径**就是解 -> 跟机器学习中说的决策树不一样，只是说明每个结点表示不同选择
   - 一般使用**递归**实现，递归树跟决策树完全一样
2. 作为题型具体指搜索一系列可行解。重点常考，并且是另外两个重点(DFS和DP)的基础
3. 题型套路
   1. (排列)有重复元素的全排列
      - 给定的序列的顺序不重要，重要的是序列都有哪些元素和各自有多少个，再依次处理每个不同的元素即可
      - 排列：相同元素不同顺序是不同的排列，因此不需要有顺序的处理。用map,数组(及下标)记录元素与个数的对应关系 （map不支持顺序遍历，可以再次遍历数组得到两个数组uniqueNum和counts来反应对应关系；也可以用map.keySet()转成可以顺序遍历的数组）
      - 排列：每个元素在原序列出现多少次对应在排列就会中出现多少次，阶段为当前要填的位置
   2. (组合) 有重复元素集合的幂集
       - 给定的序列的顺序不重要，重要的是序列都有哪些元素和各自有多少个，再依次处理每个不同的元素即可
       - 组合：需要有顺序的处理，不要回头，避免重复。用排序，数组(及下标)记录元素与个数的对应关系
       - 组合：每个元素在原序列出现多少次对应在组合中最多出现多少次，阶段为选当前相同的一批的t个数
   3. 组合总和
      - 与2类似，只是**停止条件**不同，这里不是需要做一定数量的决策，做完结束，而是和为定值时结束
      - 另外和超出target时需要提前停止，注意停止时也需要恢复现场
   4. 分割字符串
      - 分割回文串
      - 复原IP地址
        - 终止条件：串全遍历完和IP地址有4个数得同时满足
   5. 八皇后/解数独
      - 规模不大的时候，每个阶段再遍历计算得到可选列表是最直接有效的方式
      - 恢复现场不仅为后面得到结果有用，对失败搜索后重新搜索这也有用
   6. 0-1背包
   7. 正则表达式

## 深度和广度优先搜索

### 基础知识
1. 图相关的概念和算法简介
   1. 概念 ： 定点、边、无向图、有向图、有权图、度、入度、出度
   2. **树是图的一种特殊情况**
   3. 图的存储
      - 存是为了方便使用 （如果图书馆的书没有检索的需求，就杂乱地存放就好了）
        - 检查两顶点之间是否有边
        - 获取两顶点之间边的权重
        - 获取某个顶点相连的所有边/顶点
      - 邻接矩阵：若存储稀疏图比较浪费空间，但**数据的访问效率比较高**
        - 有向无权图的实现：
          ```java
          public class Graph {
            private int v;
            private boolean matrix[][];
          
            public Graph(int v) {
                this.v = v;
                matrix = new boolean[v][v];
            }
            
            public void addEdge(int s, int t) {
                matrix[s][t] = true;
                // matrix[t][s] = true; 无向
            } 
          }
          ```
      - 邻接表：哈希表+链表。适合存储稀疏图，访问两个顶点之间是否有边需要**遍历链表**
        - 有向无权图的实现：
          ```java
          public class Graph {
            private int v;
            private LinkedList<Integer> adj[];
          
            public Graph(int v) {
                this.v = v;
                adj = new LinkedList[v];
                for (int i=0; i<v; ++i) adj[i] = new LinkedList<>();
            }
          
            public void addEdge(int s, int t) {
                adj[s].add(t); // linkedList提供的在表尾添加结点的方法
                // adj[t].add(s); 无向
            } 
          }
          ```
2. 图上的各种算法简介
   1. 搜索or遍历
      - BFS & DFS
   2. 最短路径
      - Dijkstra：有权图、单源、没有负权边
      - Bellman-Ford：有权图、单源、允许负权边
      - Floyd：有权图、多源、允许负权边、不允许负权环
      - A*算法：启发式搜索算法
   3. 最小生成树
      - Prim
      - Kruskal
   4. 最大流、二分匹配
      - Ford-Fulkerson
      - Edmonds-Karp
3. 广度/深度优先搜索/遍历
   - 搜索和遍历的区别
     - 起点：链表(head)、二叉树(root)、图(起始/任意顶点）
     - 搜索：（找到t就结束）给定s,t，找是否存在一条从s到t的路径 
     - 遍历：（把队列都清空）所有结点都找到
   - BFS原理
     - "地毯式搜索" : 图上的BFS跟树上按层遍历很像，先查找离起始顶点s最近的，然后是次近的，依次往外搜索/遍历，直到找到终止顶点t/所有顶点都遍历了一遍
     - 树是一种特殊的图，二叉树的按层遍历，实际上就是广度优先搜索； 
     - BFS得到的从s到t的路径，也是s到t的最短路径
     - 图上的BFS也需要用到**队列**，除此之外，还需要一个boolean数组**visited**，有时结点太多需要hashSet存储，记录已经遍历过的顶点，防止环循环遍历
     - 时间复杂度O(E), 空间复杂度O(V)
   - DFS原理
     - "不撞南墙不回头" : 沿着一条路一直往前走，当走到无路可走时，再回退到上一个岔路口，选择另一条路继续前进
     - DFS是图上的回溯。树上的DFS的表现就是前中后序遍历，只是处理结点的时机不同。即 回溯 > DFS > 前中后序
       - 每个阶段都是基于当前顶点移动到下一个顶点
       - 可选列表是：相邻且没有被访问过的顶点
       - 当前阶段做不同的选择，对应下一个阶段是不同的，（与组合、幂集不同，与有效IP地址、分割回文串类似）
       - 结束条件：所有结点都已访问完或找到了终止顶点
       - 回溯过程中需要一个boolean数组**visited**，有时结点太多需要hashSet存储，以免循环重复遍历
     - 时间复杂度O(E), 空间复杂度O(V)

### 题型套路
1. 二维矩阵搜索或遍历
   - 机器人运动范围
2. 最短路径（无权图BFS）
   - 打开转盘锁
3. 连通分量/连通性
   - 岛屿数量
4. 拓扑排序 （有n个任务，已知两两之间的依赖关系，找一个任务执行序列，满足所有的依赖关系）
   - Kahn算法
     - 定义数据结构：如果s需要先于t执行，那就添加一条s指向t的边（先于）。所以，每个顶点的入度表示这个顶点依赖多少个其他顶点。如果某个顶点入度变成了0，就表示这个顶点没有依赖的顶点了，或者说这个顶点依赖的顶点都已经执行
     - 算法思想：入度。从图中找到一个入度为0的顶点，输出，将其可达顶点的入度都减1，循环执行此过程，直到所有顶点都被输出
       - 为了方便找入度为0的顶点，减小入度的同时维护一个入度为0的顶点list，每次遍历这个list,**类似BFS的queue**
       - 如果打印出得结点序列变少了，说明图中有环 -> **这个算法也可以用来检测环**
   - DFS算法
     - 定义数据结构：如果s需要先于t执行，那就添加一条t指向s的边（依赖）。
     - 算法思想：递归。对于顶点V,先输出其可达的所有顶点，再输出自己，即先执行V依赖的所有任务，再执行自己。
       - 每个顶点都要考察
       - **类似树上的后序遍历**
5. 检测环


## 海量数据处理
1. 两个核心问题
  - **一台机器的内存放不下** （一般来说外存是无穷的）
  - 一台机器处理起来太慢
2. 一个核心思想： 分治
  - **单机：利用外存(比如硬盘)，分批加入内存处理**
  - **多机：对数据分片，利用多机内存存储**
  - 多机：并行计算，利用多线程、多机并行处理
3. 一些处理技巧
   - 外部排序： 多路归并、桶排序
   - 哈希分片
   - 位图
4. 常见问题：先考虑在非海量的情况下如何处理，再调整方案适配海量数据的处理
  - 海量数据排序
    - 按照金额大小给10GB的订单文件进行排序 -> 离线处理
      - 单机多路归并：分批对小于内存大小（比如内存1.5G, 由于排序过程也需要一定内存，只排1G的数据）的数据做排序，再将排序结果写到外存，最后做多路归并，I/O优化：前置缓存
      - 多机多路归并：分片多机外部排序，再多路归并
      - 桶排序（范围不大且分布均匀）：先扫描一遍得到数据范围，对数据范围划分桶（外存），将数据扔到对应桶里面，对每个桶做排序再写回外存
  - 海量数据查询 
    - 10亿个整数，判断某个整数是否在其中 / 有一个包含10亿个IP地址的IP地址白名单文件，判断某IP是否在白名单中 -> 实时服务
      - 一个IP地址 -> 32位 -> 4字节， 10亿个 -> 4GB
      - 如果内存大于4GB，哈希表、红黑树即可
      - 如果内存小于4GB，用位图：IP地址范围0～2^(32)-1, 即2^32个bits，约为500MB, (估算2^10=10^3)
      - 如果内存小于500MB, 用哈希分片多机处理，考虑n台机器：对10亿个IP地址通过运算MD5(IP)%n放到对应的机器上，对每台机器上的小片数据构造哈希表、红黑树、位图等
        - 为什么要做哈希分片，而不是直接求余： MD5的随机性非常好，通过MD5将IP地址尽可能均匀地分配到每台机器上
  - 海量数据TOPK -> K个无重复
    - 10亿个整数，放在文件中，内存有限，求最大的100个整数
      - 跟在内存中求TOPK的思路一致，只不过变成从文件中读取，维护结点数量为K的小顶堆：如果新读的数大于堆顶元素，删除堆顶元素，插入新读取的数据，否则，不做处理
      - I/O优化：前置缓存，不要一次读1个数据，可以比如一次读200MB的数据
  - 海量数据求频率TOPK -> K个有重复
    - 100GB的搜索关键词文件，统计出现频率TOP100关键词
      - 先统计频率，再TOPK（堆）
        - 海量数据排序统计频率
        - 单机多次/多机，哈希分片读取到内存，统计处频率再写到外存
  - 海量数据去重/找重
    - 一个文件中包含10亿条URL,有可能回重复，将重复的去掉
      - 假设一条URL占64字节，10亿条 -> 64GB
      - 如果内存能放下：排序、哈希表 -> 海量数据的改进：
      - 排序：海量数据的排序好后，依次读取（前置缓存），如果跟上一个不一样直接写入外存（后置缓存），相同就跳过
      - 哈希表：单机多次/多机 哈希分片，前置缓存，处理，后置缓存，写入外存
  - 两海量数据找重
    - 有a,b两个文件，各自有50亿条URL,每条URL占用64字节，内存限制是4GB,找出a,b文件共同的URL
      - 如果内存能放下：排序+双指针； 哈希表 -> 改进
      - 排序+双指针：分别对a,b做海量数据排序，再双指针（即依次读取），I/0缓存优化
      - 哈希分片：单机多次/多机 分别对a,b做哈希分片，对每一片分别找重

## 动态规划
### 题型套路
- 面试重点，学习难面试不难；**掌握模型**、举一反三
- 经典模型
  - 背包问题（0-1、完全、多重、二维费用、分组、有依赖的）
  - 路径问题
  - 打家劫舍&股票买卖
  - 爬楼梯问题
  - 匹配问题（LCS、编辑距离）
  - 其他（LIS）

### 适用问题
- 适用问题： 回溯+重复子问题 **（像DFS）（每次只考虑一个实例一条路径）** -> 构建多阶段决策模型 **（像BFS）（通盘考虑）**
- 回溯解法： 适用备忘录解决重复子问题 —> 时间复杂度已经与动态规划一致，但有的问题无法用备忘录； 空间复杂度大于空间优化的动态规划
- 动态规划解法：
  - 构建多阶段决策模型。尝试画"决策"树。
  - 把每一层（每一阶段）重复的状态合并，只记录不同的状态，然后基于上一层（上一阶段）的状态集合，来推导下一层（下一阶段）的状态集合
  - **定义状态** ： 用一一映射的数组(有时用hashset)来**记录每一层的可能状态**
  - **状态转移方程** （逆推） ： -> **填表** （正推）
  - 通过合并每一层重复的状态，就避免回溯算法递归树中每层状态个数的指数级增长
- 二维费用背包问题 (无法直接用备忘录的例子)
  - 对于一组不同重量、不同价值的物品，选择将其中某些物品放入背包，在不超过背包最大重量限制的前提下，求背包中可装入物品的最大总价值
  - f(2,2,4)：已经决策完两个物品，总重量为2，总重量为4，已经求出；再遇到f(2,2,3)就没必要再求了 
  - -> 两者不同,无法直接用"相同"条件去重；如果先f(2,2,4)再f(2,2,3)可以保留最大的，第二个结点的子树没必要再求；但比如回溯的递归过程中先到f(2,2,3)，再到f(2,2,4)，两个结点下面的子树就不得不都求一遍

### 解题步骤
1. 可用回溯解决：需要穷举搜索才能得到结果的问题（最值、可行、计数等）
2. 构建多阶段决策模型 ： "决策"树。 每一阶段有几种可能的决策，一个状态就可能由上一阶段几个状态转移过来
   - 查看是否存在重复子问题：多个路径到达同一状态
   - 注意边界情况
3. **定义状态**， 即初始状态
4. **定义状态转移方程**： 当前阶段的状态可能由上一阶段的哪些状态得到
   - 画状态转移表：辅助理解
5. 编码

### 最值、可行、计数； 线性DP,树形DP；特殊小类别：~~区间DP,数位DP~~
- 例子：背包问题：有n个物品，选择其中一些物品装入背包，
  - 最值：正好装满背包所需物品的最少个数？
    - 状态：`int dp[n][w+1]`记录每阶段可达重量对应的最少物品个数。`dp[i][j]`表示第i个物品决策完之后，背包重量为j,对应的最少物品个数
    - 状态转移方程：`dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-weight[i]]+1)`
  - 最值：在不超过背包最大重量限制的前提下，可装物品总重量最大值是多少？ 
    - 状态：`boolean dp[n][w+1]` 记录每阶段可达状态； `dp[i][j] = true`表示第i个物品决策完之后背包重量为j这个状态可达
    - 状态转移方程：`dp[i][j] = dp[i-1][j] || dp[i-1][j-weight[i]]`
  - 可行：能不能正好装满背包？
    - 状态和状态转移方程与'最值'一致，只是最后返回`dp[n-1][w]`
  - 计数：装满背包有多少种不同的装法？   
    - 状态：`int dp[n][w+1]`记录每个阶段可达重量对应的装法个数。`dp[i][j]`表示第i个物品决策完之后，背包重量为j,对应有几种装法
    - 状态转移方程：`dp[i][j] = dp[i-1][j] + dp[i-1][j-weight[i]]`

### 空间优化
- 尤其是背包问题：一维数组，从后往前

## 技巧题

### 双指针
1. 常考，很多时候需要排序，求数对、特殊排序
   - 但数组上前后指针、快慢指针
   - 区间指针：快排的partition函数；选择排序的已排序未排序区间；插入排序的已排序未排序区间
   - 双数组上的指针
2. 例题
   - 数对和：找出数组中两数之和为指定值的所有整数对，一个数只能属于一个数对
     - 先排序，和小则移动左指针，和大则移动右指针
     - 相比暴力解法，提前跳过了很多不可能的组合
   - 移动零：给定一个数组，将所有0移动到数组的末尾，同时保持非零元素的相对顺序，原地操作
     - 参考快速排序的思路
        ```java
        int i = p; // “大”区间尾
        for (int j = p; j < q; j++) {
            if (nums[j] >= nums[q]) {
                swap(nums, j, i);
                i++;
            }
        }
        swap(nums, q, i); 
        ```
     - p指向非零区间的末尾，q指向未处理区间的第一位，中间区间为0
   - 最小差：两个数组a,b,计算具有最小差绝对值的一对数
     - 两个数组先排序，两个指针分别指向两个数组，小的数对应的指针后移，同时更新最小差

### 滑动窗口
1. 比较常考，求连续子串、连续子序列、连续子数组 -> 也可以看作双指针的特殊情况
2. 例题
   - 和为s的连续正数序列
     - 两个指针分别指向区间首尾
   - 最长不含重复字符的子字符串
     - 如果区间下一个字符与区间中的某个字符重复，更新左指针至重复字符的下一个位置；如果不重复，更新右指针至下一个位置

### 前缀后缀统计
1. 不常考
   - 前缀和、后缀和、前缀积、后缀积、前缀最大、后缀最大
   - 支持频繁+快速的区间统计
2. 例题
   - 买卖股票的最佳时机（一次买卖）：后缀最大
   - 不包含自身的乘积：前缀积后缀积

### 位运算
- 操作二进制位的方法叫位运算
- 基础的位运算：与（&）， 或（｜），异或(^)，取反(~)，左移（<<), 右移(>>)
- 另外十进制转二进制，二进制转十进制()
  - 十进制数转二进制数组 低位在左
    ```java
    int a = 242;
    int[] bits = new int[32];
    
    int k = 0;
    while (a != 0) {
        bits[k++] = a&1;
        a >>= 1; // a变了
    }
    
    // 另
    int mask = 1;
    for (int i = 0; i < 32; i++) {
        if (a & mask == 1) { // 超出范围时，结果为0
            bits[i] = 1;
        }
        mask <<= 1;
    }
    ```
  - 二进制数bits 转化为十进制数
    ```java
    int b = 0;
    int mask = 1;
    for (int i = 0; i < k; i++) {
        b += bits[i]*mask;
        mask <<= 1;
    }
    // 另
    int c = 0;
    for (int i = k-1; i>=0; ++i) {
        c = c<<1 + bits[i]
    }
    ```
- 例题
  - 位1的个数（汉明重量）：mask按位与的同时记录数目
  - 汉明距离：先求异或，再求汉明重量
























